import filter from 'feathers-query-filters';
import { _, each, matcher } from 'feathers-commons/lib/utils';
import * as feathersUtil from 'feathers-commons/lib/utils';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
  return typeof obj;
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};











var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};











var inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};











var possibleConstructorReturn = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (typeof call === "object" || typeof call === "function") ? call : self;
};

var each$1 = each;
var some = _.some;

/**
 * Empty function
 */
function noop() {}

/**
 * Log debug in user's console
 *
 * @param args
 */
function warn() {
  /* istanbul ignore next */
  if (console || window.console) {
    var _console;

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    (_console = console).warn.apply(_console, ['[vue-syncers-feathers]'].concat(args));
  }
}

var numberRegex = /^\d+$/;

/**
 * Test if a value seems like a number
 *
 * @param value
 * @returns {boolean}
 */

function isNumericIDLike(value) {
  return typeof value !== 'number' && numberRegex.test(value);
}

/**
 * Return object with only selected keys
 *
 * @from https://github.com/feathersjs/feathers-memory
 * @param source
 * @param keys
 * @returns {object}
 */
function pick(source) {
  var result = {};

  for (var _len2 = arguments.length, keys = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
    keys[_key2 - 1] = arguments[_key2];
  }

  for (var _iterator = keys, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
    var _ref;

    if (_isArray) {
      if (_i >= _iterator.length) break;
      _ref = _iterator[_i++];
    } else {
      _i = _iterator.next();
      if (_i.done) break;
      _ref = _i.value;
    }

    var key = _ref;

    result[key] = source[key];
  }
  return result;
}

/**
 * Check if object is JSONable
 *
 * @from https://github.com/vuejs/vue/blob/0b902e0c28f4f324ffb8efbc9db74127430f8a42/src/shared/util.js#L155
 * @param {*} obj
 * @returns {boolean}
 */
function isObject(obj) {
  return obj !== null && (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object';
}

/**
 * Loosely check if objects are equal
 *
 * @from https://github.com/vuejs/vue/blob/0b902e0c28f4f324ffb8efbc9db74127430f8a42/src/shared/util.js
 * @param {*} a
 * @param {*} b
 * @returns {boolean}
 */
function looseEqual(a, b) {
  var isObjectA = isObject(a);
  var isObjectB = isObject(b);
  if (isObjectA && isObjectB) {
    try {
      return JSON.stringify(a) === JSON.stringify(b);
    } catch (err) {
      // possible circular reference
      return a === b;
    }
  } else if (!isObjectA && !isObjectB) {
    return String(a) === String(b);
  } else {
    return false;
  }
}

var variables = {
	loading: function loading() {
		return this.$loadingSyncers;
	}
};

var methods = {
	refresh: function refresh() {
		return this.$refreshSyncers.apply(this, arguments);
	},
	service: function service() {
		var _$feathers;

		return (_$feathers = this.$feathers).service.apply(_$feathers, arguments);
	}
};

/**
 * Create mixin by passed in options
 *
 * @param {Boolean|Object} options
 */
function aliasesMixinMaker(options) {
	var isEnabled = void 0;
	if (typeof options === 'boolean') {
		isEnabled = function isEnabled() {
			return options;
		};
	} else {
		isEnabled = function isEnabled(key) {
			return key in options && options[key];
		};
	}

	var mixin = {
		computed: {}, // variables
		methods: {}
	};

	each$1(variables, function (getter, key) {
		if (isEnabled(key)) {
			mixin.computed['$' + key] = getter;
		}
	});

	each$1(methods, function (caller, key) {
		if (isEnabled(key)) {
			mixin.methods['$' + key] = caller;
		}
	});

	return mixin;
}

var BaseFeathersSyncer = function () {

	/**
  * Create a syncer for feathers
  *
  * @param Vue
  * @param vm
  * @param path
  * @param settings
  */
	function BaseFeathersSyncer(Vue, vm, path, settings) {
		classCallCheck(this, BaseFeathersSyncer);

		this.Vue = Vue;
		this.vm = vm;
		this.path = path;
		this.settings = settings;

		this.filters = {};
		this.unwatchers = {};
		this.events = {
			loaded: settings.loaded,
			error: settings.errored
		};

		Vue.util.defineReactive(this, 'state', this._initialState());
		Vue.util.defineReactive(this, 'loading', true);

		this._id = 'idField' in settings ? settings.idField : Vue.$syncer.idField;

		var client = Vue.$syncer.feathers;
		this.service = client.service(this.settings.service);
	}

	/**
  * Cleanup after oneself
  */


	BaseFeathersSyncer.prototype.destroy = function destroy() {
		each$1(this.unwatchers, function (unwatcher) {
			unwatcher();
		});

		this.state = this._initialState();
		this.vm = this.settings = this.Vue = this.service = null;
	};

	/**
  * Hook into feathers and set up value observers
  *
  * @returns {*}
  */


	BaseFeathersSyncer.prototype.ready = function ready() {
		this._listenForServiceEvent('created', this.onItemCreated.bind(this));
		this._listenForServiceEvent('updated', this.onItemUpdated.bind(this));
		this._listenForServiceEvent('patched', this.onItemUpdated.bind(this));
		this._listenForServiceEvent('removed', this.onItemRemoved.bind(this));

		return this._bindComputedValues();
	};

	/**
  * Refresh syncer's value
  */


	BaseFeathersSyncer.prototype.refresh = function refresh() {
		return this._loadNewState();
	};

	/**
  * Handle errors loading the state
  *
  * @param error
  * @private
  */


	BaseFeathersSyncer.prototype._handleStateLoadingError = function _handleStateLoadingError(error) {
		this.loading = false;
		this._fireEvent('error', error);
	};

	/**
  * Register service listener and unlistener
  *
  * @param event
  * @param callback
  * @private
  */


	BaseFeathersSyncer.prototype._listenForServiceEvent = function _listenForServiceEvent(event, callback) {
		var _this = this;

		/* istanbul ignore next */
		if (process.env.NODE_ENV !== 'production') {
			var origCallback = callback;
			callback = function callback() {
				if (_this.Vue === null) {
					warn('Removed event listener is being called. Please update feathers-socket-commons package.');
					return;
				}

				origCallback.apply(undefined, arguments);
			};
		}

		this.service.on(event, callback);
		this.unwatchers['service-' + event] = function () {
			_this.service.off(event, callback);
		};
	};

	/**
  * Wrapper for loading current state
  *
  * @returns {Promise.<T>}
  * @private
  */


	BaseFeathersSyncer.prototype._loadNewState = function _loadNewState() {
		this.loading = true;
		return this._loadState();
	};

	/**
  * Mark as everything's now loaded
  *
  * @private
  */


	BaseFeathersSyncer.prototype._newStateLoaded = function _newStateLoaded() {
		this.loading = false;
		this._fireEvent('loaded');
	};

	/**
  * Fire event on both listeners in settings and instance
  *
  * @private
  */


	BaseFeathersSyncer.prototype._fireEvent = function _fireEvent(event) {
		var _vm;

		for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
			args[_key - 1] = arguments[_key];
		}

		if (event in this.events && this.events[event]) {
			this.events[event].apply(this.vm, args);
		}
		(_vm = this.vm).$emit.apply(_vm, ['syncer-' + event, this.path].concat(args));
	};

	return BaseFeathersSyncer;
}();

/**
 * Collection syncer used for multiple items
 */

var CollectionSyncer = function (_BaseSyncer) {
	inherits(CollectionSyncer, _BaseSyncer);

	/**
  * Create a syncer for feathers
  *
  * @param Vue
  * @param vm
  * @param path
  * @param settings
  */
	function CollectionSyncer(Vue, vm, path, settings) {
		classCallCheck(this, CollectionSyncer);

		var _this = possibleConstructorReturn(this, _BaseSyncer.call(this, Vue, vm, path, settings));

		_this._matcher = function () {
			return true;
		}; // For without query
		_this._createMatcher = Vue.$syncer.matcher;
		_this._filterParser = Vue.$syncer.filter;
		return _this;
	}

	/**
  * Handle new item creations from feathers
  *
  * @param item
  */


	CollectionSyncer.prototype.onItemCreated = function onItemCreated(item) {
		if (this._itemMatches(item)) {
			item = this._transformPerQuery(item);
			this._set(item[this._id], item);
		}
	};

	/**
  * Handle item updates from feathers
  *
  * @param item
  */


	CollectionSyncer.prototype.onItemUpdated = function onItemUpdated(item) {
		if (this._itemMatches(item)) {
			item = this._transformPerQuery(item);
			this._set(item[this._id], item);
		} else if (item[this._id] in this.state) {
			this._remove(item[this._id]);
		}
	};

	/**
  * Handle item removals from feathers
  *
  * @param item
  */


	CollectionSyncer.prototype.onItemRemoved = function onItemRemoved(item) {
		if (item[this._id] in this.state) {
			this._remove(item[this._id]);
		}
	};

	/**
  * Bind watchers for computed values
  *
  * @private
  */


	CollectionSyncer.prototype._bindComputedValues = function _bindComputedValues() {
		var _this2 = this;

		if ('query' in this.settings) {
			this.filters.query = null;

			// When new value is found
			var callback = function callback(newVal) {
				// Avoid re-querying if it's the same
				if (looseEqual(this.filters.query, newVal)) {
					this.filters.query = newVal;
					return;
				}

				this.filters.query = newVal;
				if (newVal === null) {
					this.filters.queryParsed = null;
				} else {
					this.filters.queryParsed = this._filterParser(newVal);
				}

				// Clear state (if query is now null it makes sure everything's reset)
				this.state = this._initialState();
				this._matcher = function () {
					return false;
				};

				// Default return nothing
				var returning = false;
				if (this.filters.query !== null) {
					this._matcher = this._createMatcher(this.filters.query);
					returning = this._loadNewState();
				}

				if ('hook' in callback) {
					callback.hook(returning);
					delete callback.hook;
				}
			};

			return new Promise(function (resolve) {
				callback.hook = resolve;

				_this2.unwatchers.query = _this2.vm.$watch(_this2.settings.query, callback.bind(_this2), { immediate: true });
			});
		}

		return this._loadNewState();
	};

	/**
  * Initial data for item syncer
  *
  * @returns {*}
  * @private
  */


	CollectionSyncer.prototype._initialState = function _initialState() {
		return {};
	};

	/**
  * Checks if item matches what's in collection
  *
  * @param item
  * @returns {boolean}
  * @private
  */


	CollectionSyncer.prototype._itemMatches = function _itemMatches(item) {
		return this._matcher(item);
	};

	/**
  * Load the requested state
  *
  * @returns {Promise.<T>}
  * @private
  */


	CollectionSyncer.prototype._loadState = function _loadState() {
		var _this3 = this;

		var params = {};

		if (this.filters.query) {
			params.query = this.filters.query;
		}

		return this.service.find(params).then(function (items) {
			if (_this3.vm === null) {
				// destroy has been called during loading
				return items;
			}

			_this3.state = _this3._initialState();

			// if the service is paginated
			if (Array.isArray(items) === false && typeof items.data !== 'undefined') {
				items = items.data;
			}

			items.forEach(function (item) {
				_this3._set(item[_this3._id], item);
			});
			_this3._newStateLoaded();

			return items;
		}).catch(this._handleStateLoadingError.bind(this));
	};

	/**
  * Set current item
  *
  * @param key
  * @param item
  * @private
  */


	CollectionSyncer.prototype._set = function _set(key, item) {
		this.Vue.set(this.state, key, item);
	};

	/**
  * Remove current item
  *
  * @private
  */


	CollectionSyncer.prototype._remove = function _remove(key) {
		this.Vue.delete(this.state, key);
	};

	/**
  * Transform item using current filter's rules
  *
  * @param item
  * @private
  */


	CollectionSyncer.prototype._transformPerQuery = function _transformPerQuery(item) {
		if (this.filters.queryParsed) {
			var filters = this.filters.queryParsed.filters;
			if (filters.$select) {
				item = pick.apply(undefined, [item].concat(filters.$select));
			}
		}
		return item;
	};

	return CollectionSyncer;
}(BaseFeathersSyncer);

/**
 * Item syncer used for when there's no constraints
 */

var ItemSyncer = function (_BaseSyncer) {
	inherits(ItemSyncer, _BaseSyncer);

	function ItemSyncer() {
		classCallCheck(this, ItemSyncer);
		return possibleConstructorReturn(this, _BaseSyncer.apply(this, arguments));
	}

	/**
  * Handle new item creations from feathers
  *
  * @param item
  */
	ItemSyncer.prototype.onItemCreated = function onItemCreated(item) {
		if (item[this._id] === this.filters.id) {
			this._set(item);
		}
	};

	/**
  * Handle item updates from feathers
  *
  * @param item
  */


	ItemSyncer.prototype.onItemUpdated = function onItemUpdated(item) {
		if (item[this._id] === this.filters.id) {
			this._set(item);
		}
	};

	/**
  * Handle item removals from feathers
  *
  * @param item
  */


	ItemSyncer.prototype.onItemRemoved = function onItemRemoved(item) {
		if (item[this._id] === this.filters.id) {
			this._remove();
		}
	};

	/**
  * Bind watchers for computed values
  *
  * @private
  */


	ItemSyncer.prototype._bindComputedValues = function _bindComputedValues() {
		var _this2 = this;

		this.filters.id = null;

		// When new value is found
		function callback(newVal) {
			this.filters.id = newVal;

			// Warn about string id's that seem like they shooooouldn't
			/* istanbul ignore next */
			if (process.env.NODE_ENV !== 'production' && isNumericIDLike(newVal)) {
				warn('String ID that looks like a number given', this.path, newVal);
			}

			// Clear state (if now null it just makes sure)
			this.state = this._initialState();

			// Default return nothing
			var returning = false;
			if (this.filters.id !== null) {
				returning = this._loadNewState();
			}

			if ('hook' in callback) {
				callback.hook(returning);
				delete callback.hook;
			}
		}

		return new Promise(function (resolve) {
			callback.hook = resolve;

			_this2.unwatchers.id = _this2.vm.$watch(_this2.settings.id, callback.bind(_this2), { immediate: true });
		});
	};

	/**
  * Initial data for item syncer
  *
  * @returns {*}
  * @private
  */


	ItemSyncer.prototype._initialState = function _initialState() {
		return null;
	};

	/**
  * Load the requested state
  *
  * @returns {Promise.<T>}
  * @private
  */


	ItemSyncer.prototype._loadState = function _loadState() {
		var _this3 = this;

		return this.service.get(this.filters.id).then(function (item) {
			if (_this3.vm === null) {
				// destroy has been called during loading
				return item;
			}

			_this3._set(item);
			_this3._newStateLoaded();

			return item;
		}).catch(this._handleStateLoadingError.bind(this));
	};

	/**
  * Set current item
  *
  * @param item
  * @private
  */


	ItemSyncer.prototype._set = function _set(item) {
		this.Vue.set(this, 'state', item);
	};

	/**
  * Remove current item
  *
  * @private
  */


	ItemSyncer.prototype._remove = function _remove() {
		this.state = this._initialState();
	};

	return ItemSyncer;
}(BaseFeathersSyncer);

/**
 * Chooses and returns the preferred syncer
 *
 * @param Vue
 * @param vm
 * @param path
 * @param settings
 * @returns {BaseFeathersSyncer}
 */
function syncerChooser(Vue, vm, path, settings) {
	if (typeof settings === 'string') {
		settings = {
			service: settings
		};
	}

	// Choose syncer to use
	if ('id' in settings) {
		return new ItemSyncer(Vue, vm, path, settings);
	}
	return new CollectionSyncer(Vue, vm, path, settings);
}

/**
 * Install mixin onto the Vue instance
 *
 * @param {Vue} Vue - Vue
 */
var syncerMixin = function (Vue) {
	var _ref;

	var VueVersion = Number(Vue.version && Vue.version.split('.')[0]);
	var initHook = VueVersion && VueVersion > 1 ? 'beforeCreate' : 'init';

	return _ref = {}, _ref[initHook] = beforeCreate(Vue), _ref.created = created(), _ref.beforeDestroy = beforeDestroy(), _ref.computed = {
		$loadingSyncers: loadingStateGetter
	}, _ref.methods = {
		$refreshSyncers: refreshSyncers
	}, _ref;
};

/*
 * Before creation hook
 *
 * @param {Vue} Vue - Vue
 */
function beforeCreate(Vue) {
	return function () {
		var _this = this;

		this._syncers = {};

		var SyncCreator = Vue.$syncer.driver;
		var synced = this.$options.sync;
		if (synced) {
			// Set up each syncer
			each$1(synced, function (settings, key) {
				_this._syncers[key] = new SyncCreator(Vue, _this, key, settings);

				Object.defineProperty(_this, key, {
					get: function get() {
						return _this._syncers[key] ? _this._syncers[key].state : null;
					},
					set: noop,
					enumerable: true,
					configurable: true
				});
			});
		}
	};
}

/**
 * After creation hook
 */
function created() {
	return function () {
		// Start syncers
		each$1(this._syncers, function (syncer) {
			syncer.ready();
		});
	};
}

/**
 * Before destruction hook
 */
function beforeDestroy() {
	return function () {
		var _this2 = this;

		each$1(this._syncers, function (syncer, key) {
			syncer.destroy();
			delete _this2._syncers[key];
		});
	};
}

/**
 * Get loading state of the syncers
 *
 * @returns {boolean}
 */
function loadingStateGetter() {
	if (Object.keys(this._syncers).length > 0) {
		return some(this._syncers, function (syncer) {
			return syncer.loading;
		});
	}
	return false;
}

/**
 * Refresh syncers state
 *
 * @param {string|string[]} [keys] - Syncers to refresh
 */
function refreshSyncers(keys) {
	var _this3 = this;

	if (typeof keys === 'string') {
		keys = [keys];
	}
	if (!keys) {
		keys = Object.keys(this._syncers);
	}
	return Promise.all(keys.map(function (key) {
		return _this3._syncers[key].refresh();
	}));
}

var defaults = {
	aliases: false,
	driver: syncerChooser,
	filter: filter,
	idField: 'id',
	matcher: matcher
};

var index = {
	/**
  * Install to vue
  *
  * @function
  * @param {Vue} Vue - Vue
  * @param {Object} options - Options
  * @param {Function} [options.aliases] - Aliases to enable
  * @param {Function} [options.driver] - Custom driver to use
  * @param {Function} [options.filter] - Query filter parser
  * @param {Object} [options.feathers] - Feathers client
  * @param {string} [options.idField] - Default ID field
  * @param {Function} [options.matcher] - Matcher creator
  */
	install: function install(Vue) {
		var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

		var extend = Vue.util.extend;
		// Vue 2.0 has util.toObject, but 1.0 doesn't
		options = extend(extend({}, defaults), options);

		if (!('feathers' in options)) {
			throw new Error('No feathers instance set in options');
		}

		Vue.$syncer = options;
		Vue.prototype.$feathers = options.feathers;

		Vue.mixin(syncerMixin(Vue));
		// Mixin handling
		Vue.config.optionMergeStrategies.sync = Vue.config.optionMergeStrategies.props;

		if (options.aliases) {
			Vue.mixin(aliasesMixinMaker(options.aliases));
		}
	}
};

export default index;
